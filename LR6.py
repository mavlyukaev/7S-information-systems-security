import struct


# Инициализация S-блока
def initialize_s_block():
    # Создаем таблицу подстановки (S-блок) размером 256 элементов
    s_block = [0] * 256
    # Заполняем S-блок значениями, используя побитовые операции для создания 32-битных слов
    for i in range(256):
        s_block[i] = (i << 24) | (i << 16) | (i << 8) | i
    return s_block


# Генерация ключевого потока на основе начального ключа
def generate_keystream(key, length):
    # Инициализируем S-блок
    s_block = initialize_s_block()
    keystream = []  # Список для хранения элементов ключевого потока
    r3, r4, r5, r6 = key  # Разбиваем ключ на 4 32-битных регистра

    # Генерируем ключевой поток заданной длины
    for _ in range(length):
        # Обновляем значения регистров с использованием арифметических операций
        r3 = (r3 + r5) & 0xFFFFFFFF  # Ограничиваем значения 32 битами
        r4 = (r4 + r6) & 0xFFFFFFFF
        r5 = (r5 + r3) & 0xFFFFFFFF
        r6 = (r6 + r4) & 0xFFFFFFFF

        # Генерируем элемент ключевого потока с использованием таблицы подстановки
        t = (s_block[(r3 >> 24) & 0xFF] ^  # Берем старший байт r3
             s_block[(r4 >> 16) & 0xFF] ^  # Средний байт r4
             s_block[(r5 >> 8) & 0xFF] ^  # Второй младший байт r5
             s_block[r6 & 0xFF])  # Младший байт r6
        keystream.append(t)  # Добавляем элемент в ключевой поток
    return keystream


# Функция для шифрования и дешифрования данных
def wake_cipher(data, key):
    # Дополняем данные до длины, кратной 4 байтам, если необходимо
    padding_length = (4 - len(data) % 4) % 4
    data += b'\x00' * padding_length  # Дополняем нулевыми байтами
    data = bytearray(data)  # Преобразуем данные в изменяемый массив байтов

    # Генерируем ключевой поток для шифрования/дешифрования
    keystream = generate_keystream(key, len(data) // 4)

    # Проходим по данным блоками по 4 байта
    for i in range(0, len(data), 4):
        # Извлекаем 4 байта данных и преобразуем в 32-битное слово
        block = struct.unpack('>I', data[i:i + 4])[0]
        # Применяем XOR с соответствующим элементом ключевого потока
        block ^= keystream[i // 4]
        # Записываем результат обратно в массив данных
        data[i:i + 4] = struct.pack('>I', block)

    return bytes(data)  # Возвращаем данные в виде неизменяемого байтового объекта


# Пример использования функции шифрования/дешифрования
if __name__ == "__main__":
    # Пример 128-битного ключа, представленного четырьмя 32-битными словами
    key = (0x12345678, 0x23456789, 0x34567890, 0x45678901)

    # Исходный текст, который нужно зашифровать (используем русский текст)
    plaintext = "Пример текста, который нужно зашифровать.".encode('utf-8')  # Кодируем строку в байты

    # Выполняем шифрование
    ciphertext = wake_cipher(plaintext, key)
    # Выполняем дешифрование и удаляем дополненные нулевые байты
    decrypted = wake_cipher(ciphertext, key).rstrip(b'\x00').decode('utf-8')  # Декодируем байты в строку

    # Выводим результаты
    print("Исходный текст:", plaintext.decode('utf-8'))
    print("Зашифрованный текст:", ciphertext)
    print("Расшифрованный текст:", decrypted)
